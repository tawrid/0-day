<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8"><title>0-Day Vulnerability Report 2024-06-10</title>
<style>
body { font-family: sans-serif; margin: 0; padding: 20px; }
.cve-item { border: 1px solid #ccc; padding: 12px; margin: 10px 0; border-radius: 6px; }
a { text-decoration: none; color: #0645ad; }
</style>
</head><body>
<h1>0-Day Vulnerabilities for 2024-06-10</h1>

        <div class="cve-item">
            <h3><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-36971" target="_blank">CVE-2024-36971</a></h3>
            <p>In the Linux kernel, the following vulnerability has been resolved:

net: fix __dst_negative_advice() race

__dst_negative_advice() does not enforce proper RCU rules when
sk->dst_cache must be cleared, leading to possible UAF.

RCU rules are that we must first clear sk->sk_dst_cache,
then call dst_release(old_dst).

Note that sk_dst_reset(sk) is implementing this protocol correctly,
while __dst_negative_advice() uses the wrong order.

Given that ip6_negative_advice() has special logic
against RTF_CACHE, this means each of the three ->negative_advice()
existing methods must perform the sk_dst_reset() themselves.

Note the check against NULL dst is centralized in
__dst_negative_advice(), there is no need to duplicate
it in various callbacks.

Many thanks to Clement Lecigne for tracking this issue.

This old bug became visible after the blamed commit, using UDP sockets.</p>
        </div>
</body></html>
