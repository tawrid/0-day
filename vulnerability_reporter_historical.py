#!/usr/bin/env python3
import os
from time import sleep
import requests
import datetime
from dateutil.rrule import rrule, DAILY

REPORTS_DIR = "reports"
REPORT_FILE_NAME = "index.html"

NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
CISA_KEV_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"


def fetch_cisa_kev():
    """Fetch Known Exploited Vulnerabilities (KEV) list from CISA."""
    print("Fetching CISA KEV catalog...")
    try:
        resp = requests.get(CISA_KEV_URL, timeout=30)
        resp.raise_for_status()
        kev_data = resp.json()
        kev_ids = {item["cveID"] for item in kev_data.get("vulnerabilities", [])}
        print(f"Loaded {len(kev_ids)} KEV CVEs.")
        return kev_ids
    except Exception as e:
        print(f"Error fetching KEV: {e}")
        return set()


def fetch_cves_for_day(api_key: str, day: datetime.date):
    """Fetch CVEs published on a specific day (UTC)."""
    start_time = datetime.datetime.combine(day, datetime.time.min).replace(tzinfo=datetime.timezone.utc)
    end_time = datetime.datetime.combine(day, datetime.time.max).replace(tzinfo=datetime.timezone.utc)

    params = {
        "pubStartDate": start_time.isoformat(),
        "pubEndDate": end_time.isoformat(),
        "resultsPerPage": 2000,
    }
    headers = {"apiKey": api_key} if api_key else {}

    try:
        resp = requests.get(NVD_API_URL, params=params, headers=headers, timeout=60)
        resp.raise_for_status()
        data = resp.json()
        return data.get("vulnerabilities", [])
    except Exception as e:
        print(f"Error fetching NVD CVEs for {day}: {e}")
        return []


def filter_zero_days(cves, kev_ids):
    """Return CVEs that are in KEV and match the filter."""
    zero_days = []
    for item in cves:
        cve_id = item.get("cve", {}).get("id")
        if cve_id in kev_ids:
            zero_days.append(item)
    return zero_days


def extract_exploit_links(cve_item):
    """Extract public exploit references from CVE references."""
    links = []
    refs = cve_item.get("cve", {}).get("references", [])

    # Handle both v2 formats
    if isinstance(refs, dict) and "reference_data" in refs:
        ref_list = refs["reference_data"]
    elif isinstance(refs, list):
        ref_list = refs
    else:
        ref_list = []

    for ref in ref_list:
        url = ref.get("url", "") if isinstance(ref, dict) else str(ref)
        tags = [tag.lower() for tag in ref.get("tags", [])] if isinstance(ref, dict) else []
        if any(tag in ["exploit", "proof-of-concept"] for tag in tags) or \
           any(domain in url for domain in ["exploit-db.com", "github.com", "packetstormsecurity.com"]):
            links.append(url)
    return links



def generate_html(cve_list, date_str):
    """Generate HTML for 0-day report."""
    items_html = ""
    for item in cve_list:
        cve = item["cve"]
        cve_id = cve["id"]
        desc = (
            cve["descriptions"][0]["value"]
            if cve.get("descriptions")
            else "No description."
        )
        link = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
        exploit_links = extract_exploit_links(item)

        items_html += f"""
        <div class="cve-item">
            <h3><a href="{link}" target="_blank">{cve_id}</a></h3>
            <p>{desc}</p>
        """
        if exploit_links:
            items_html += "<p><strong>Exploits:</strong></p><ul>"
            for e in exploit_links:
                items_html += f'<li><a href="{e}" target="_blank">{e}</a></li>'
            items_html += "</ul>"
        items_html += "</div>"

    return f"""<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8"><title>0-Day Vulnerability Report {date_str}</title>
<style>
body {{ font-family: sans-serif; margin: 0; padding: 20px; }}
.cve-item {{ border: 1px solid #ccc; padding: 12px; margin: 10px 0; border-radius: 6px; }}
a {{ text-decoration: none; color: #0645ad; }}
</style>
</head><body>
<h1>0-Day Vulnerabilities for {date_str}</h1>
{items_html}
</body></html>
"""


def save_report(day: datetime.date, zero_days):
    """Save the report under /YYYY-MM-DD only if there are 0-days and not already saved."""
    if not zero_days:
        return False

    date_str = day.strftime("%Y-%m-%d")
    output_dir = os.path.join(REPORTS_DIR, date_str)
    report_path = os.path.join(output_dir, REPORT_FILE_NAME)

    if os.path.exists(report_path):
        print(f"‚è© Skipping {date_str}, report already exists.")
        return False

    os.makedirs(output_dir, exist_ok=True)
    html = generate_html(zero_days, date_str)

    with open(report_path, "w", encoding="utf-8") as f:
        f.write(html)

    print(f"‚úÖ 0-day report created for {date_str} ‚Üí {report_path}")
    return True


def update_index():
    """Generate top-level index.html linking to all 0-day reports."""
    base_dir = os.path.join(REPORTS_DIR)
    index_path = os.path.join(base_dir, "index.html")
    if not os.path.exists(base_dir):
        return

    dates = sorted([d for d in os.listdir(base_dir) if os.path.isdir(os.path.join(base_dir, d))], reverse=True)

    with open(index_path, "w", encoding="utf-8") as f:
        f.write("<html><head><title>0-Day Reports</title></head><body>")
        f.write("<h1>0-Day Vulnerability Reports Archive</h1><ul>")
        for d in dates:
            f.write(f'<li><a href="{d}/">{d}</a></li>')
        f.write("</ul></body></html>")

    print(f"üìÑ Top-level index updated ‚Üí {index_path}")


if __name__ == "__main__":
    api_key = os.getenv("NVD_API_KEY", "")
    kev_ids = fetch_cisa_kev()

    today = datetime.date.today()

    # One-off backfill from 2025-01-01 until today
    start_date = datetime.date(2012, 1, 1)
    for dt in rrule(DAILY, dtstart=start_date, until=today):
        day = dt.date()
        print(f"Checking {day}...")
        cves = fetch_cves_for_day(api_key, day)
        zero_days = filter_zero_days(cves, kev_ids)
        if zero_days:
            save_report(day, zero_days)
            sleep(5)  # polite delay

    # Update top-level index
    update_index()

    print("üéâ Backfill complete. Future days should be handled by cron.")
